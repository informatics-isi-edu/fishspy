#!/usr/bin/python

import os
import sys
import json
import csv
import math
import numpy as np
import scipy.ndimage.filters
import png
import re

pos_bin_cnt = 5

def main(eventcsv, framecsv):

    # extract CS periods as [ (CS_on_frame, US_on_frame or -1, off_frame), ... ]
    CS_periods = []
    
    frameno_idx = None
    comment_idx = None
    t0 = None
    t1 = -1
    t2 = None

    f = open(eventcsv, 'r')
    for row in csv.reader(f):
        if frameno_idx is None:
            frameno_idx = row.index('frameno')
            comment_idx = row.index('comment')
        else:
            comment = row[comment_idx]
            pattern = 'light state='
            pos = comment.find(pattern)
            if pos >= 0:
                state = comment[pos + len(pattern):][0:2]
                if state == 'CS' and t0 is None:
                    t0 = int(row[frameno_idx])
                elif state == 'US' and t1 == -1:
                    if t0 is None:
                        t0 = int(row[frameno_idx])
                    else:
                        t1 = int(row[frameno_idx])
                elif state == 'of':
                    t2 = int(row[frameno_idx])
                    assert t0 < t2
                    assert t1 < t2
                    assert t1 > t0 or t1 == -1, (t0, t1, t2)
                    CS_periods.append( (t0, t1, t2) )
                    t0 = None
                    t1 = -1
                    t2 = None

    if CS_periods:
        CS_periods = np.array(CS_periods, dtype=np.int32)
        CS_cnt = CS_periods.shape[0]
        CS_max_duration = (CS_periods[:,2] - CS_periods[:,0]).max()
        CS_cycles = (CS_periods[1:,0] - CS_periods[0:-1,0])

        print "%d periods, %d frames max duration, %f average cycle, %d median cycle" % (CS_cnt, CS_max_duration, CS_cycles.mean(), np.median(CS_cycles))
    else:
        print "found 0 CS periods... control experiment?"
        CS_periods = None
        CS_cnt = 0
        CS_max_duration = None
        CS_cycles = None

    # extract binned position data into array with shape FxB for B bins
    frame_bins = []
    frameno_idx = None
    pos_bin_idxs = None
    frameno = -1
    
    for row in csv.reader(open(framecsv, 'r')):
        if frameno_idx is None:
            frameno_idx = row.index('frameno')
            pos_bin_idxs = [ row.index('position bin %d' % i) for i in range(5) ]
        else:
            assert int(row[frameno_idx]) == (frameno + 1), (frameno, row)
            frameno = int(row[frameno_idx])
            frame_bins.append( [ int(row[idx]) for idx in pos_bin_idxs ] )

    frame_bins = np.array(frame_bins, dtype=np.int32)

    print "%d frames, %d position bins" % frame_bins.shape
    print "%d min/%d avg/%d max position spread" % (frame_bins.min(), frame_bins.mean(), frame_bins.max())

    # HACK:  guess at FPS for reduction ratio... assume k * 20 fps  and approximate total duration
    fps = int(frame_bins.shape[0] / 200000.0) * 20

    print "guessed %s frames/sec" % fps

    # zeros mean invalid measurements
    invalid = np.zeros(frame_bins.shape, dtype=np.bool)

    invalid = frame_bins == 0
    invalid[1:,:] += frame_bins[0:-1,:] == 0
    invalid[0,:] = 1

    # get optional invalid mask from user
    user_invalid = [ int(x) for x in os.getenv('FISHSPY_INVALID_BINS', '').split(',') if x ]
    if len(user_invalid) < invalid.shape[1]:
        user_invalid.extend([ 0 for x in range(invalid.shape[1] - len(user_invalid)) ])
    elif len(user_invalid) > invalid.shape[1]:
        user_invalid = user_invalid[0:invalid.shape[1]]
    user_invalid = np.array(user_invalid, dtype=np.bool)
    invalid += user_invalid
    user_invalid = user_invalid[None,:]
        
    # characterize statically invalid bins from aggregate TODO: other percentile threshold?
    static_invalid = np.median(invalid[:,:], axis=0).astype(np.bool)[None,:] | user_invalid

    # absolute interframe deltas, filling first frame with zeros
    frame_delta_bins = np.zeros(frame_bins.shape, dtype=np.float32)
    frame_delta_bins[1:,:] = np.abs(frame_bins[1:,:] - frame_bins[0:-1,:])

    # replace invalid with black (no motion)
    frame_delta_bins = np.ma.masked_array(frame_delta_bins, mask=invalid)
    frame_delta_bins = np.ma.filled(frame_delta_bins, fill_value=0.0)

    # replace dynamic invalid with max_value (max motion)
    max_level = frame_delta_bins.max()
    frame_delta_bins = np.ma.masked_array(frame_delta_bins, mask=np.logical_and(invalid, np.invert(static_invalid[:,:])))
    frame_delta_bins = np.ma.filled(frame_delta_bins, fill_value=max_level)

    # use the X percentile tail-speed estimate from k/5 bins at each timestep
    temp = np.percentile(frame_delta_bins, 100. * 4.5/5, axis=1)[:,None]
    # mask out boundaries to de-glitch at global illumination changes
    if CS_periods is not None:
        for period in range(CS_cnt):
            temp[CS_periods[period,0]-1:CS_periods[period,0]+2,:] = 0
            temp[CS_periods[period,1]-1:CS_periods[period,0]+2,:] = 0
            temp[CS_periods[period,2]-1:CS_periods[period,2]+2,:] = 0

    # smear tail-speed over time
    temp = scipy.ndimage.filters.gaussian_filter(temp, sigma=0.4) # size is 6sigma - 1, sigma=1.35->diameter 7.1

    # thresholded motion values as boolean
    frame_activity = (temp >= (temp.mean() + 0.04 * (temp.max()-temp.mean())  ))

    print "%d min/%d avg/%d max delta position spread" % (frame_delta_bins.min(), frame_delta_bins.mean(), frame_delta_bins.max())

    us_cs_ratio = float(os.getenv('FISHSPY_US_CS_RATIO', '0.2'))
    trial_periods = None
    static_trial_phases = False
    trial_counts = os.getenv('FISHSPY_TRIAL_COUNTS')
    trial_counts = trial_counts.split(',')
    assert len(trial_counts) == 4, "FISHSPY_TRIAL_COUNTS must be comma-separated list of 4 decimal integers"
    trial_counts = np.array([ int(x) for x in trial_counts ], dtype=np.int32)

    # determine analysis and plot space

    if CS_periods is not None:
        # prefer to use detected values if movie events were found
        width = int(np.median(CS_cycles))
        preroll = int((width - CS_max_duration) / 3.0)
        draw_boundaries = True

        trial_periods = np.zeros( (4,), dtype=np.int32 )
        for cs, us, off in CS_periods:
            # HACK: assume valid US detection is at least 5 seconds * 20fps after CS detection
            if (us - cs) <= 100:
                if trial_periods[2] == trial_periods[1]:
                    trial_periods[1:] += 1
                else:
                    trial_periods[3:] += 1
            else:
                if trial_periods[3] == trial_periods[2]:
                    trial_periods[2:] += 1
        if len(CS_periods) == trial_periods[1]:
            # reset due to lack of detected US periods, i.e. older 2-level illumination movies
            trial_periods = None
        else:
            print "trial_periods from events: %s" % trial_periods
    else:
        assert trial_counts is not None, "Must provide FISHSPY_TRIAL_COUNTS for control data lacking CS periods"

        # mock up state to try to plot control data
        CS_cnt = trial_counts.sum()
        width = int(128 * fps)
        preroll = int(width / 3.0)

        # pretend we have uniform zero-width CS periods to fool the plot method
        CS_periods = np.array(
            [
                ( i * width + preroll, -1, i * width + preroll)
                for i in range(CS_cnt)
            ],
            np.int32
        )

        draw_boundaries = False

    if trial_counts is not None and trial_periods is None:
        # use env. supplied trial counts as fallback when detection failed for old or control movies
        trial_periods = np.zeros( (4,), dtype=np.int32 )
        for p in range(1,4):
            trial_periods[p] = trial_counts[0:p].sum()
        static_trial_phases = True
        print "trial_periods from ENV: %s" % trial_periods

    assert width > 1000, "CS interval detection has failed to find a reasonable interval width"

    img = np.zeros((CS_cnt, pos_bin_cnt + 1, width, 3), dtype=np.float32)

    print "%s plot space" % (img.shape,)

    csv_cycle_rows = [
        ('cycle', '', 'act_00_30', 'act_85_130'),
    ]

    habit_rounds = []
    train_rounds = []
    test_rounds = []
    retrain_rounds = []

    for period in range(CS_cnt):

        # one data cycle
        d0 = CS_periods[period, 0] - preroll
        d1 = CS_periods[period + 1, 0] if period < (CS_cnt - 1) else frame_bins.shape[0]
        dw = min(d1 - d0, img.shape[2])
        d1 = d0 + dw
        
        dL = CS_periods[period, 2] - CS_periods[period, 0]

        # figure out offset for preroll and padding if not enough preroll data available
        pad = abs(d0) if d0 < 0 else 0
        d0 += pad
        i0 = pad
        i1 = pad + dw

        # draw bins green using motion data
        img[period,1:,i0:i1,1] = frame_delta_bins[d0:d1,:].transpose((1,0))

        # draw motion periods with magenta flags
        img[period,0:1,i0:i1,0] = frame_activity[d0:d1].transpose((1,0)) * max_level/4.0
        img[period,0:1,i0:i1,2] = frame_activity[d0:d1].transpose((1,0)) * max_level/4.0

        # measure cycle activity windows 0-75% and 80-130% relative to CS on/off boundaries
        w0 = CS_periods[period, 0]
        w100 = CS_periods[period, 2]
        ww = w100 - w0
        w15 = int(0.30 * ww) + w0
        w85 = int(0.85 * ww) + w0
        w130 = int(1.30 * ww) + w0

        act_00_30 = np.abs(frame_activity[w0:w15,0]).sum() > 0
        act_85_130 = np.abs(frame_activity[w85:w130,0]).sum() > 0
        cycle_type = 'CS'

        if draw_boundaries:
            img[period,:,preroll,2] = max_level
            img[period,:,preroll + dL,2] = max_level

            # HACK: assume valid US detection is at least 5 seconds * 20fps after CS detection
            if (CS_periods[period, 1] - CS_periods[period, 0]) > 100:
                # show unconditioned stimulus marker too
                US_offset = CS_periods[period,1] - CS_periods[period,0]
                #
                img[period,:,preroll + US_offset,2] = max_level
                img[period,:,preroll + US_offset,0] = max_level
                #
                cycle_type = 'CS+US'
            elif static_trial_phases and ((trial_periods[1] <= period < trial_periods[2]) or (trial_periods[2] < trial_periods[3] <= period)):
                # show unconditioned stimulus marker too
                #
                img[period,:,preroll + int(dL * (1.0 - us_cs_ratio)),2] = max_level
                img[period,:,preroll + int(dL * (1.0 - us_cs_ratio)),0] = max_level
                #
                cycle_type = 'CS+US'


        measures = (act_00_30, act_85_130)
        if trial_periods[0] <= period < trial_periods[1]:
            habit_rounds.append( measures )
        elif trial_periods[1] <= period < trial_periods[2]:
            train_rounds.append( measures )
        elif trial_periods[2] <= period < trial_periods[3]:
            test_rounds.append ( measures )
        elif trial_periods[3] <= period:
            retrain_rounds.append( measures )

        csv_cycle_rows.append(
            (period, cycle_type, act_00_30, act_85_130)
        )

    img = img.reshape((CS_cnt * (pos_bin_cnt + 1), img.shape[2], 3))

    img_full = img

    # 20 fps -> 7x reduce
    x_reduce = int(img.shape[1] / 360.0)
    
    img = np.zeros( (img_full.shape[0], img_full.shape[1] / x_reduce, img_full.shape[2]), dtype=np.float32)

    for i in range(x_reduce):
        img[:,:,:] += img_full[:,slice(i,img.shape[1]*x_reduce,x_reduce),:]

    print "%s plot image shape using %d x-reduction" % (img.shape, x_reduce)

    img = np.sqrt(img)
    img *= 255.0 / img[:,:,1].max()
    img = np.clip(img * 3.0, 0.0, 255.0)

    print "%s min/%s avg/%s max plot spread" % (img.min(), img.mean(), img.max())

    m1 = re.match('^(?P<id>[^.]+)[.]events[.]csv(?P<version>:[^:]+)?$', os.path.basename(eventcsv))
    m2 = re.match('^(?P<id>[^.]+)[.]frame_measures[.]csv(?P<version>:[^:]+)?$', os.path.basename(framecsv))
    if m1 and m2 and m1.groupdict().get('id') == m2.groupdict().get('id'):
        png_filename2 = '%s.plot2.png' % m1.groupdict().get('id')
        csv_filename = '%s.sums.csv' % m1.groupdict().get('id')
        json_filename = '%s.grade.json' % m1.groupdict().get('id')
    else:
        # old-style for backward compatibility
        png_filename2 = 'movie_plot2.png'
        csv_filename = 'movie_sums.csv'
        json_filename = 'movie_grade.json'

    png.from_array(img.astype(np.uint8), mode='RGB').save(png_filename2)

    outf = open(csv_filename, 'w')
    writer = csv.writer(outf)
    for row in csv_cycle_rows:
        writer.writerow(row)
    del writer
    outf.close()

    habit_check = habit_rounds[-10:]
    train_check = train_rounds
    test_check = test_rounds

    grade = {
        "habituation_denominator": len(habit_check),
        "habituation_us_numerator": len([ True for a1, a2 in habit_check if a1 ]),
        "training_denominator": len(train_check),
        "training_us_numerator": len([ True for a1, a2 in train_check if a1 ]),
        "training_cs_numerator": len([ True for a1, a2 in train_check if a2 ]),
        "testing_denominator": len(test_check),
        "testing_us_numerator": len([ True for a1, a2 in test_check if a1 ]),
    }
    grade.update({
        "habituated": float(grade["habituation_us_numerator"])/grade["habituation_denominator"] <= 6./20 if grade["habituation_denominator"] else None,
        "aversive": float(grade["training_cs_numerator"])/grade["training_denominator"] >= 14./20 if grade["training_denominator"] else None,
    })
    if not grade["habituated"]:
        grade["summary"] = "bhv_no_habituation"
    elif not grade["aversive"]:
        grade["summary"] = "bhv_no_aversion"
    elif float(grade["testing_us_numerator"])/grade["testing_denominator"] >= 4.5/5 if grade["testing_denominator"] else None:
        grade["summary"] = "bhv_learner"
    elif float(grade["testing_us_numerator"])/grade["testing_denominator"] <= 0.5/5 if grade["testing_denominator"] else None:
        grade["summary"] = "bhv_nonlearner"
    else:
        grade["summary"] = "bhv_inconclusive"

    outf = open(json_filename, 'w')
    print(json.dumps(grade))
    json.dump(grade, outf)
    outf.close()

if __name__ == '__main__':
    events = sys.argv[1]
    frames = sys.argv[2]
    exit(main(events, frames))

